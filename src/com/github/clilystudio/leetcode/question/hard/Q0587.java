/*******************************************************************************
 * Copyright 2019 ClilyStudio.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/
package com.github.clilystudio.leetcode.question.hard;

import java.util.List;

import com.github.clilystudio.leetcode.define.Point;

/// -----------------------------------------------------------------------------
/// [587] 安装栅栏
///
/// https://leetcode-cn.com/problems/erect-the-fence/description/
///
/// 在一个二维的花园中，有一些用 (x, y)
/// 坐标表示的树。由于安装费用十分昂贵，你的任务是先用最短的绳子围起所有的树。只有当所有的树都被绳子包围时，花园才能围好栅栏。你需要找到正好位于栅栏边界上的树的坐标。
///
/// 示例 1:
///
/// 输入: [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]
/// 输出: [[1,1],[2,0],[4,2],[3,3],[2,4]]
/// 解释:
///
/// 示例 2:
///
/// 输入: [[1,2],[2,2],[4,2]]
/// 输出: [[1,2],[2,2],[4,2]]
/// 解释:
///
/// 即使树都在一条直线上，你也需要先用绳子包围它们。
///
/// 注意:
///
/// 所有的树应当被围在一起。你不能剪断绳子来包围树或者把树分成一组以上。
/// 输入的整数在 0 到 100 之间。
/// 花园至少有一棵树。
/// 所有树的坐标都是不同的。
/// 输入的点没有顺序。输出顺序也没有要求。
/// -----------------------------------------------------------------------------
public class Q0587 {
    public List<Point> outerTrees(Point[] points) {
        // TODO
        return null;
    }
}
